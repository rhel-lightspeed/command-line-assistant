use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Configuration for the CLAD service
/// Loaded from config.toml file
#[derive(Clone, Debug, Deserialize)]
pub struct Config {
    /// Backend settings for communicating with the external API
    pub backend: BackendConfig,
    /// Logging configuration settings
    #[serde(default)]
    pub logging: LoggingConfig,
    /// Database configuration (deprecated)
    #[serde(default)]
    pub database: Option<DatabaseConfig>,
    /// History configuration (deprecated)
    #[serde(default)]
    pub history: Option<HistoryConfig>,
}

impl Config {
    /// Load configuration from a TOML file
    #[allow(dead_code)]
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let contents = fs::read_to_string(path)?;
        let config: Config = toml::from_str(&contents)?;

        Ok(config)
    }

    /// Get the tracing filter string from the log level
    pub fn get_tracing_filter(&self) -> String {
        let level = self.logging.level.to_lowercase();
        format!("clad={}", level)
    }
}

/// Backend API configuration
#[derive(Clone, Debug, Deserialize)]
pub struct BackendConfig {
    /// The endpoint points to an API server
    pub endpoint: String,
    /// HTTP request timeout in seconds (increase for CPU inference)
    #[serde(default = "default_timeout")]
    pub timeout: u64,
    /// HTTP/HTTPS proxy configuration for outgoing requests
    pub proxies: Option<HashMap<String, String>>,
    /// Authentication settings
    #[allow(dead_code)]
    pub auth: AuthConfig,
}

/// Authentication configuration
#[derive(Clone, Debug, Deserialize)]
pub struct AuthConfig {
    /// The path to the certificate file generated by RHSM
    #[allow(dead_code)]
    pub cert_file: String,
    /// The path to the key file generated by RHSM
    #[allow(dead_code)]
    pub key_file: String,
}

/// Logging configuration
#[derive(Clone, Debug, Deserialize, Default)]
pub struct LoggingConfig {
    /// The default logging level for all messages logged by CLAD
    #[serde(default = "default_log_level")]
    pub level: String,
    /// Audit logging settings (deprecated)
    #[serde(default)]
    pub audit: Option<AuditConfig>,
}

/// Audit logging configuration (deprecated)
#[derive(Clone, Debug, Deserialize)]
#[allow(dead_code)]
pub struct AuditConfig {
    /// If enabled, we will log audit tracing to journald
    pub enabled: bool,
}

/// Database configuration (deprecated)
#[derive(Clone, Debug, Deserialize)]
#[allow(dead_code)]
pub struct DatabaseConfig {
    /// Available types for databases are: sqlite, postgresql and mysql
    #[serde(rename = "type")]
    pub db_type: String,
    /// Connection string for sqlite database
    pub connection_string: Option<String>,
    /// Database host
    pub host: Option<String>,
    /// Database port
    pub port: Option<String>,
    /// Database username
    pub username: Option<String>,
    /// Database password
    pub password: Option<String>,
    /// Database name
    pub database: Option<String>,
}

/// History configuration (deprecated)
#[derive(Clone, Debug, Deserialize)]
#[allow(dead_code)]
pub struct HistoryConfig {
    /// If the history for all conversation should be enabled or not
    pub enabled: bool,
}

fn default_timeout() -> u64 {
    30
}

fn default_log_level() -> String {
    "INFO".to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test basic config deserialization
    #[test]
    fn test_config_deserialization() {
        let config_str = r#"
            [backend]
            endpoint = "http://localhost:9000"
            timeout = 30

            [backend.auth]
            cert_file = "/path/to/cert.pem"
            key_file = "/path/to/key.pem"

            [logging]
            level = "INFO"
        "#;

        let config: Result<Config, _> = toml::from_str(config_str);
        assert!(config.is_ok(), "Config should deserialize successfully");

        let config = config.unwrap();
        assert_eq!(config.backend.endpoint, "http://localhost:9000");
    }

    /// Test proxies field for reqwest HTTP/HTTPS proxy
    #[test]
    fn test_config_with_proxies() {
        let config_str = r#"
            [backend]
            endpoint = "http://localhost:9000"
            timeout = 30
            proxies = { http = "http://proxy:8002", https = "https://proxy:8443" }

            [backend.auth]
            cert_file = "/path/to/cert.pem"
            key_file = "/path/to/key.pem"

            [logging]
            level = "INFO"
        "#;

        let config: Result<Config, _> = toml::from_str(config_str);
        assert!(config.is_ok(), "Config should deserialize successfully");

        let config = config.unwrap();
        assert!(config.backend.proxies.is_some());
        assert_eq!(
            config
                .backend
                .proxies
                .as_ref()
                .unwrap()
                .get("http")
                .unwrap(),
            "http://proxy:8002"
        );
        assert_eq!(
            config
                .backend
                .proxies
                .as_ref()
                .unwrap()
                .get("https")
                .unwrap(),
            "https://proxy:8443"
        );
    }

    /// Test config with minimal required fields
    #[test]
    fn test_config_minimal() {
        let config_str = r#"
            [backend]
            endpoint = "http://localhost:9000"

            [backend.auth]
            cert_file = "/path/to/cert.pem"
            key_file = "/path/to/key.pem"
        "#;

        let config: Result<Config, _> = toml::from_str(config_str);
        assert!(config.is_ok(), "Minimal config should be valid");

        let config = config.unwrap();
        assert_eq!(config.backend.endpoint, "http://localhost:9000");
        assert!(config.backend.proxies.is_none());
    }

    /// Test config with all optional fields
    #[test]
    fn test_config_with_all_optional_fields() {
        let config_str = r#"
            [backend]
            endpoint = "http://localhost:9000"
            timeout = 60
            proxies = { http = "http://proxy:8002" }

            [backend.auth]
            cert_file = "/path/to/cert.pem"
            key_file = "/path/to/key.pem"

            [logging]
            level = "DEBUG"
        "#;

        let config: Result<Config, _> = toml::from_str(config_str);
        assert!(config.is_ok());

        let config = config.unwrap();
        assert_eq!(config.backend.timeout, 60);
        assert_eq!(config.logging.level, "DEBUG");
        assert!(config.backend.proxies.is_some());
    }

    /// Test tracing filter generation
    #[test]
    fn test_tracing_filter_generation() {
        let config_str = r#"
            [backend]
            endpoint = "http://localhost:9000"

            [backend.auth]
            cert_file = "/path/to/cert.pem"
            key_file = "/path/to/key.pem"

            [logging]
            level = "DEBUG"
        "#;

        let config: Config = toml::from_str(config_str).unwrap();
        let filter = config.get_tracing_filter();

        assert_eq!(filter, "clad=debug");
    }

    /// Test default values are applied correctly
    #[test]
    fn test_config_defaults() {
        let config_str = r#"
            [backend]
            endpoint = "http://localhost:9000"

            [backend.auth]
            cert_file = "/path/to/cert.pem"
            key_file = "/path/to/key.pem"
        "#;

        let config: Config = toml::from_str(config_str).unwrap();

        // Check defaults
        assert_eq!(config.backend.timeout, 30); // default timeout
        assert!(config.backend.proxies.is_none()); // no proxy by default
    }
}
